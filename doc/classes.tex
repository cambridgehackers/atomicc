%!TEX root = std.tex
\rSec0[class]{Classes}%

\gramSec[agram.class]{Classes}

\rSec1[atomicc.module]{Module declaration and definition}

A module, defined using the keyword "__module", results in the generation of 
a corresponding verilog module in the compilation output file.
It includes local state elements, interfaces exported, interfaces imported
and rules for clustering operations into atomic transactions.

Modules are independently compiled, even if they exist in the same compilation
unit.  Rule and interface method scheduling logic is generated as part of the
generated module.  Scheduling constraints (read set, write set and relation to
other scheduled elements) are generated into a metadata file, allowing
schedule consistency between modules to be verified by the linker.

\begin{example}
\begin{codeblock}
     __module Echo {
         EchoRequest      request;               // exported interface (defined by this module)
         EchoIndication   *indication;           // imported interface (defined by the instantiator of this module)
         bool busy;
         __int(32) itemSay;
         ...
         // implementation of method request.say(). Note the guard "if (!busy)".
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
         void request.saw(__int(16) a, __int(16) b) if(!busy) {
             ...
         }
     };
\end{codeblock}
\end{example}

To reference a module from a separate compilation unit, use "__emodule".  External
module definitions need only specify the exported/imported interfaces.

\begin{example}
\begin{codeblock}
     __module EchoResponder {
         EchoIndication   indication;           // exported interface
     };
\end{codeblock}
\end{example}

\rSec1[atomicc.interface]{Module interface definition}

An AtomicC interface is essentially an abstract class similar to a
Java interface. All the methods are virtual and no default
implementations are provided. AtomicC style uses composition of
interfaces (using __connect) rather than inheritance.

The __interface keyword defines a list of methods that are exposed from an object that
can be composed as a unit.
Instead of using object inheritance to define reusable interfaces,
they are defined/exported explicitly by objects, allowing fine-grained
specification of interface method visibility.

Methods of a module are translated to value ports for passing the
method arguments and a pair of handshaking ports used for scheduling
method invocations.

References to an object can only be done through interface methods.  State element
declarations inside an object (member variables) are private.

\begin{example}
\begin{codeblock}
     __interface EchoRequest {
         void say(__int(32) v);
         void say2(__int(16) a, __int(16) b);
     };
\end{codeblock}
\end{example}

\rSec1[atomicc.guard]{Guard clauses on module interface methods}

\pnum
Method definitions in __module declarations have the form:

\begin{bnf}
\nontermdef{atomicc-method-definition}\br
    \opt{decl-specifier-seq} interface-qualifier-seq identifier parameters-and-qualifiers function-body
\end{bnf}

\begin{bnf}
\nontermdef{interface-qualifier}\br
    identifier \terminal{.}

\nontermdef{interface-qualifier-seq} \br
    interface-qualifier \br
    interface-qualifier-seq interface-qualifier
\end{bnf}

\begin{bnf}
\nontermdef{atomicc-function-body}\br
    \opt{if-guard} compound-statement

\nontermdef{if-guard}\br
    \terminal{if (} condition \terminal{)}

\end{bnf}


Rules are only ready to fire if the rule's guard is true and all the
guards on methods invoked within the rule are also true.

\begin{codeblock}
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
\end{codeblock}

\rSec1[atomicc.connect]{Connecting exported interfaces to imported references}
The __connect statement allows exported interface declarations to be connected
with imported interface references between objects within a module declaration.

\begin{bnf}
\nontermdef{connect-declaration}\br
    \terminal{__connect} identifier \terminal{=} identifier \terminal{;}
\end{bnf}

\begin{example}
\begin{multicols}{2}
AtomicC example
\begin{codeblock}
     __interface ExampleRequest {
         void say(__int(32) v);
     };

     __module A {
          ExampleRequest callIn;
     };

     __module B {
         ExampleRequest *callOut;
     };

     __module C {
         A consumer;
         B producer;
         __connect producer.callOut = consumer.callIn;
     };
\end{codeblock}
\columnbreak
BSV example
\begin{codeblock}
    BSV example
    BSV example
    BSV example
    BSV example
    BSV example
\end{codeblock}
\end{multicols}
\end{example}

Comparision with BSV:
\begin{itemize}
\item The declaration for 'A' is just like BSV.
In BSV, the declaration for B requires the interface instance for 'callOut' be passed in as
an interface parameter (forcing a textual ordering to the source code
declaration sequence).
\item In AtomicC, the interfaces are stitched together outside in any
convenient sequence in a location where both the concrete instances
for A and B are visible.
\end{itemize}

\rSec1[atomicc.export]{Exporting interfaces from contained objects}

In a design, there are times when the engineer wishes to declare an object locally,
but allow external modules to access specific interfaces of the local object.
This is done by declaring an interface to the containing object of compatible
type and just 'assigning' the local object's interface to it.

\begin{example}
\begin{codeblock}
     __module CWrapper {
         A consumer;
         ExampleRequest request = A.callIn;
      };
\end{codeblock}
\end{example}

CWrapper just forwards the interface 'request' down into the instance 'consumer'.

\rSec1[atomicc.classsyn]{Syntax extension to C++}
\begin{bnf}
\nontermdef{atomicc-class-key}\br
    \terminal{__interface} \br
    \terminal{__emodule} \br
    \terminal{__module}
\end{bnf}

\rSec1[atomicc.softif]{Exporting interfaces for use by software}

In systems that have both hardware and software components, there is a need to marshall/demarshall
parameterized method invocations across a hardware bus or network-on-chip (NOC).
AtomicC provides this with my decorating the interface declarations with the keyword "__software".

The use of the __software keyword causes the following to be performed:
\begin{itemize}
\item The generation of serialization/deserialization code for both software and hardware side modules
to allow the method invocations to be performed in each direction
\item The generation of header files allowing compilation of software modules that
interface with the hardware
\item Integration into a modified Connectal execution framework for the orchestration of requests.
\end{itemize}

\begin{example}
\begin{codeblock}
     __module Echo {
         __software EchoRequest      request;               // exported interface
         __software EchoIndication   *indication;           // imported interface
         bool busy;
         __int(32) itemSay;
         ...
         // implementation of method request.say(). Note the guard "if (!busy)".
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
         void request.saw(__int(16) a, __int(16) b) if(!busy) {
             ...
         }
     };
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
#include "EchoIndication.h"  // Header file generated by AtomicC
#include "EchoRequest.h"     // Header file generated by AtomicC

class EchoIndication : public EchoIndicationWrapper
{
public:
    virtual void heard(uint32_t v) {
        // user code for handling indication
    }
    EchoIndication(unsigned int id, PortalTransportFunctions *item, void *param) :
        EchoIndicationWrapper(id, item, param) {}
};

int main(int argc, const char **argv)
{
    EchoIndication echoIndication(IfcNames_EchoIndicationH2S, &transportMux, &param);
    EchoRequestProxy echoRequestProxy(IfcNames_EchoRequestS2H, &transportMux, &param);

    // user code for sending requests
    echoRequestProxy->say(42);
}
\end{codeblock}
\end{example}
