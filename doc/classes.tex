%!TEX root = std.tex
\rSec0[class]{Classes}%

\gramSec[agram.class]{Classes}

\rSec1[atomicc.module]{__module, __emodule}

A module is defined using the keyword "__module", resulting in generation of 
a corresponding output verilog module.
It includes local state elements, interfaces exported, interfaces imported
and rules for clustering operations into atomic transactions.

Modules are independently compiled, even if they exist in the same compilation
unit.  Rule and interface method scheduling logic is generated as part of the
generated module.  Scheduling constraints (read set, write set and relation to
other scheduled elements) are generated into a metadata file, allowing
schedule consistency between modules to be verified by the linker.

\begin{example}
\begin{codeblock}
     __module Echo {
         EchoRequest      request;               // exported interface
         EchoIndication   *indication;           // imported interface
         bool busy;
         __int(32) itemSay;
         ...
         // implementation of method request.say(). Note the guard "if (!busy)".
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
         void request.saw(__int(16) a, __int(16) b) if(!busy) {
             ...
         }
     };
\end{codeblock}
\end{example}

To reference a separately compiled module, use "__emodule".  These external
module definitions only need to include the exported/imported interfaces.

\begin{example}
\begin{codeblock}
     __module EchoResponder {
         EchoIndication   indication;           // exported interface
     };
\end{codeblock}
\end{example}

\rSec1[atomicc.interface]{__interface}

An AtomicC interface is essentially an abstract class similar to a
Java interface. All the methods are virtual and no default
implementations are provided. AtomicC style uses composition of
interfaces rather than inheritance.

The __interface keyword defines a list of methods that are exposed from an object.
Instead of using object inheritance to define reusable interfaces,
they are defined/exported explicitly by objects, allowing fine-grained
specification of interface method visibility.

Methods of a module are translated to value ports for passing the
method arguments and a pair of handshaking ports used for scheduling
method invocations.

References to an object can only be done through interface methods.  State element
declarations inside an object (member variables) are private.

\begin{example}
\begin{codeblock}
     __interface EchoRequest {
         void say(__int(32) v);
         void say2(__int(16) a, __int(16) b);
     };
\end{codeblock}
\end{example}

\rSec1[atomicc.guard]{guard clauses on module interface methods}

\pnum
Method definitions in __module declarations have the form:

\begin{bnf}
\nontermdef{atomicc-method-definition}\br
    \opt{decl-specifier-seq} interface-qualifier-seq identifier parameters-and-qualifiers function-body
\end{bnf}

\begin{bnf}
\nontermdef{interface-qualifier}\br
    identifier \terminal{.}

\nontermdef{interface-qualifier-seq} \br
    interface-qualifier \br
    interface-qualifier-seq interface-qualifier
\end{bnf}

\begin{bnf}
\nontermdef{atomicc-function-body}\br
    \opt{ctor-initializer} \opt{if-guard} compound-statement

\nontermdef{if-guard}\br
    \terminal{if (} condition \terminal{)}

\end{bnf}


Rules are only ready to fire if the rule's guard is true and all the
guards on methods invoked within the rule are also true.

\begin{codeblock}
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
\end{codeblock}

\rSec1[atomicc.connect]{__connect}
The __connect statement allows exported interface declarations to be connected
with imported interface references between objects within a module declaration.

\begin{bnf}
\nontermdef{connect-declaration}\br
    \terminal{__connect} identifier \terminal{=} identifier \terminal{;}
\end{bnf}

\begin{example}
\begin{codeblock}
     __interface ExampleRequest {
         void say(__int(32) v);
     };

     __module A {
          ExampleRequest callIn;
     };

     __module B {
         ExampleRequest *callOut;
     };

     __module C {
         A consumer;
         B producer;
         __connect producer.callOut = consumer.callIn;
     };
\end{codeblock}
\end{example}

Comparision with BSV:
\begin{itemize}
\item The declaration for 'A' is just like BSV.
In BSV, the declaration for B requires the interface be passed in as
an interface parameter (forcing a textual ordering to the source code
declaration sequence).
\item In AtomicC, the interfaces are stitched together outside in any
convenient sequence in a location where both the concrete instances
for A and B are visible.
\end{itemize}

\rSec1[atomicc.export]{To export interfaces from contained objects}

\begin{example}
\begin{codeblock}
     __module CWrapper {
         A consumer;
         ExampleRequest request = A.callIn;
      };
\end{codeblock}
\end{example}

CWrapper just forwards the interface 'request' down into the instance 'consumer'.

\rSec1[atomicc.classsyn]{Syntax extension to C++}
\begin{bnf}
\nontermdef{atomicc-class-key}\br
    \terminal{__interface} \br
    \terminal{__emodule} \br
    \terminal{__module}
\end{bnf}
