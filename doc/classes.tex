%!TEX root = std.tex
\rSec0[class]{Classes}%
\indextext{class|(}

\gramSec[gram.class]{Classes}

\pnum
A class is a type.
Its name becomes a \grammarterm{class-name}\iref{class.name} within its
scope.

\begin{bnf}
\nontermdef{atomicc-class-key}\br
    \terminal{__interface} \br
    \terminal{__emodule} \br
    \terminal{__module}
\end{bnf}

\rSec2[atomicc.interface]{__interface}

An AtomicC interface is essentially an abstract class similar to a
Java interface. All the methods are virtual and no default
implementations are provided. AtomicC style uses composition of
interfaces rather than inheritance.

The __interface keyword defines a list of methods that are exposed from an object.
Instead of using object inheritance to define reusable interfaces,
they are defined/exported explicitly by objects, allowing fine-grained
specification of interface method visibility.

Methods of a module are translated to value ports for passing the
method arguments and a pair of handshaking ports used for scheduling
method invocations.

References to an object can only be done through interface methods.  State element
declarations inside an object (member variables) are private.

Example:
\begin{codeblock}
     __interface EchoRequest {
         void say(__int(32) v);
         void say2(__int(16) a, __int(16) b);
     };
\end{codeblock}

\rSec2[atomicc.module]{__module, __emodule}

A module is defined using the keyword "__module", resulting in generation of verilog.
It includes local state elements, interfaces exported, interfaces imported
and rules for clustering operations into atomic units.

Example:
\begin{codeblock}
     __module Echo {
         EchoRequest      request;               // exported interface
         EchoIndication   *indication;           // imported interface
         bool busy;
         __int(32) itemSay;
         ...
         // implementation of method request.say(). Note the guard "if (!busy)".
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
         void request.saw(__int(16) a, __int(16) b) if(!busy) {
             ...
         }
     };
\end{codeblock}

To reference a separately compiled module, use "__emodule".  These external
module definitions only need to include the exported/imported interfaces.

Example:
\begin{codeblock}
     __module EchoResponder {
         EchoIndication   indication;           // exported interface
     };
\end{codeblock}

\rSec2[atomicc.guard]{guard clauses on methods}

Rules are only ready to fire if the rule's guard is true and all the
guards on methods invoked within the rule are also true.

\begin{codeblock}
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
\end{codeblock}

\rSec2[atomicc.connect]{__connect}
The __connect statement allows exported interface declarations to be connected
with imported interface references between objects within a module declaration.

Example:
\begin{codeblock}
     __interface ExampleRequest {
         void say(__int(32) v);
     };

     __module A {
          ExampleRequest callIn;
     };

     __module B {
         ExampleRequest *callOut;
     };

     __module C {
         A consumer;
         B producer;
         __connect producer.callOut = consumer.callIn;
     };
\end{codeblock}

* Comparision with BSV
    The declaration for 'A' is just like BSV.
    In BSV, the declaration for B requires the interface be passed in as
    an interface parameter (forcing a textual ordering to the source code
    declaration sequence).
    <br>
    In AtomicC, the interfaces are stitched together outside in any
    convenient sequence in a location where both the concrete instances
    for A and B are visible.

\rSec2[atomicc.export]{To export interfaces from contained objects}

Example:
\begin{codeblock}
     __module CWrapper {
         A consumer;
         ExampleRequest request = A.callIn;
      };
\end{codeblock}

CWrapper just forwards the interface 'request' down into the instance 'consumer'.

\begin{bnf}
\nontermdef{atomicc-method-declaration}\br
    \opt{attribute-specifier-seq} \opt{pin-type} \opt{decl-specifier-seq} \opt{member-declarator-list} \terminal{;}

\nontermdef{connect-declaration}\br
    \terminal{__connect} identifier \terminal{=} identifier \terminal{;}

\nontermdef{forward-declaration}\br
    \terminal{__forward} identifier \terminal{=} identifier \terminal{;}

\nontermdef{printf-declaration}\br
    \terminal{__printf ;}

\end{bnf}

\begin{bnf}
\nontermdef{pin-type} \br
    \terminal{__input} \br
    \terminal{__output} \br
    \terminal{__inout} \br
    \terminal{__parameter}
\end{bnf}

