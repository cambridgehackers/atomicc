%!TEX root = std.tex
\rSec0[stmt.stmt]{Statements}%

\gramSec[agram.stmt]{Statements}

\rSec1[atomicc.rule]{__rule}

Rules specify a group of operations that must execute as an atomiclly.
A rule operates
transactionally: when a rule's guard and the guards of all of its
method invocations are satisfied, then it is ready to fire. It will
fire on a clock cycle when it does not conflict with any higher
priority rule.

\begin{bnf}
\nontermdef{rule-statement}\br
    \terminal{__rule} identifier \opt{if-guard} compound-statement\br

\end{bnf}

\begin{example}
\begin{codeblock}
     __rule respond_rule if (responseAvail) {
         fifo->out.deq();
         ind->heard(fifo->out.first());
     }
\end{codeblock}
\end{example}

\rSec1[atomicc.nostmt]{Restrictions on C++ statements}

Unlike the serialized execution model of C++, AtomicC supports a fully parallel,
single cycle execution of rules which satisfy which are able to fire.

Since AtomicC does not generate any extra logic to support sequential execution behavior from
language constructs,
traditional C++ statements with non-static control flow behavior are not supported.

Examples include:
\begin{itemize}
\item Non-constant bound "for" statements.  Constant bound "for" statements that can be fully unrolled
are supported.
\item "do", "while" statements
\item Usages of "goto" that result in a cyclic directed graph of execution blocks
\item Method and function calls that are not inlinable at compilation time (for example, recursion is prohibited)
\end{itemize}

