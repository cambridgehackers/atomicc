%!TEX root = std.tex
\rSec0[atomicc.basic]{Basic}

\rSec1[atomicc.intro]{Introduction}

AtomicC is a timed, structural hardware description language for
the high level specification of algorithms to be instantiated
directly in hardware.
AtomicC extends C++
with support for Guarded Atomic Actions:
Bluespec-style\cite{Bluespec:www,Hoe:Thesis,HoeArvind:TRS_Synthesis2}
modules, rules, interfaces, and methods.
AtomicC does not attempt to emulate the behavior of all C++ constructs in hardware,
instead uses a subset of the C++ language to specify behavioral
assignments to state elements.

The language is designed for
the construction of \textbf{modules} that are correct-by-construction \textit{composable}:
validated smaller modules can be aggregated to form
a larger validated module with
no degradation of the component modules:
\begin{itemize}
\item Modules interactions are performed with Latency Insensitive (LI)
\cite{carloni2001theory}
\textbf{method} calls, allowing methods to enforce invocation pre-conditions
and transitive support for stalling.
\item Module behaviorial statements are encapsulated into transactions (\textbf{rules})
following ACID semantics
\cite{NikhilSemantics}
\cite{harris2005composable}
\cite{nurvitadhi2011automatic}
\cite{fox2003algebraic}.
The compiler synthesizes control signals, allowing rules to fire
only when their referenced method invocations are ready.

In AtomicC, all enabled rules in all modules execute on every clock cycle.
The compiler
validates that rules executed during a given clock cycle are
"sequentially consistent"(SC) \cite{Lamport:1979:MMC:1311099.1311750},
guaranteeing each rule executes
independently of any other rules executing at the same time
(\textit{isolation}\cite[Sec.~7.1]{GrayR93}).
\item An \textbf{interface} is a named collection of method signatures, defining
the behavior of an abstract data type(ADT) \cite{Liskov74programmingwith}.
Modules can export and import
multiple, named \textbf{interfaces},
giving flexibility in coupling with other modules and in algorithm expression.
\item All state elements in the hardware
netlist are explicit in the source code of the design.
All module data is private to the module.
\end{itemize}
These features support the reliable reuse of pre-compiled, incrementally validated
libraries, improving productivity on large designs.

Like Connectal, AtomicC designs may include both hardware and
software components, using interfaces to specify hardware/software communication
in a type safe manner. The AtomicC compiler generates the code and transactors to pass
arguments between hardware and software.

The AtomicC compiler 
generates a single Verilog module for each AtomicC module declared.
Existing Verilog modules can be called from and can call AtomicC
generated modules.
Standard Verilog backend tools are used to synthesize
the resulting ASIC or FPGA.

The basic building block of AtomicC is the module declaration.
Modules consist of 3 parts:
\begin{itemize}
\item Instantiation of state elements used by the module,
\item Interface declarations for interacting from other modules,
\item Rules, which group assignment statements and method invocations into atomic transactions.
\end{itemize}

\rSec1[atomicc.interface]{Interfaces}

Exported interfaces can be used in several ways:
\begin{itemize}
\item invoked directly by the instantiator of the module,
\item forwarded transparently, becoming another exported interface of the instantiating module,
\item 'connected' to an 'interface reference' of another module in the instantiating scope.
\end{itemize}

There are 2 types of methods:
\begin{itemize}
\item \textbf{Value method functions} provide read-only access to module state elements.
\item \textbf{Action method procedures} perform write operations on state elements,
can take parameters and do not have return values.
A compiler generated
\textbf{valid} signal indicates that the caller wishes to perform the method invocation.
\end{itemize}

Both types of methods use a compiler generated \textbf{ready} signal
to indicate when the callee is available and
to prevent scheduling of the calling transaction until all necessary elements are
available.

AtomicC uses a \textbf{valid/ready} \textit{hand-shaking signalling}
\cite{Fletcher2009, AXISpec} to invoke action methods,
giving both the invoker(master) and invokee(slave) the ability to control transaction
execution timing.
The master uses the \textbf{valid} signal
of the method to show when parameter data is available and the transaction should be performed.
The method invocation transaction succeeds only when
both \textbf{valid} and \textbf{ready} are HIGH:

 ($\pi(M_{i}) \equiv ready(M_{i})\ \&\&\ valid(M_{i})$).

\rSec2[atomicc.schedule]{Scheduling}

In contrast to software, which uses \textit{dynamic allocation}\cite[p.~377]{GrayR93}
and locking\cite[Sec.~11.2]{OV11} to guarantee isolation,
the set of state elements accessed by an AtomicC transaction
and the boolean condition when the transaction is performed
are all known at compile time.
This allows \textit{static allocation}\cite[Sec.~7.3.1]{GrayR93} of schedules
and compile time validation of SC.

When scheduling, rules with overlap in usage of state elements
(\textit{read set} and \textit{write set}\cite[Sec.~10.1.2]{OV11} \cite{RosenkrantzSternsLewis})
are greedily gathered into \textit{schedule sets}, each of which is
validated with a \textit{constraint graph}.
A \textit{constraint graph} is a partially-ordered digraph that models
the dependencies within a \textit{schedule set}:
nodes in a constraint graph represent atomic rule instances, edges
represent the ordering relations between these instances\cite[Sec.~3]{Cain2003}.
Since all reads of state elements occur at the beginning of a clock period,
all edges in the graph are \textbf{Write-after-read (WAR)}.
Each edge has a symbolic boolean \textit{edge condition} for when the
the ordering dependency actually exists: the boolean
condition when one rule actually reads a given state element
and another rule actually writes it.

The transitive closure of these orders on the constraint graph nodes
dictate the sequence (\textbf{schedule}) in which each rule must \textit{appear} to execute in
order to be considered correct
\cite[Sec.~11.1]{OV11}.
Of course, since all rules execute in a single cycle, "schedule" does not
refer to an actual time sequenced evolution of state,
but to a conceptual "sub-cycle" ordering.

For each pair of nodes in the constraint digraph, we define the \textit{node condition}
between 2 nodes as the 'fold' of the \textit{edge conditions} of each WAR edge
using the 'or' operator.
For each cycle in the digraph, we define the \textit{path condition}
as the 'fold' of the \textit{node conditions} for all sequential pairs of nodes
in the cycle using the 'and' operator.

If a cycle has a \textit{path condition} that is not identically false,
then, when the \textit{path condition} is true, a total ordering of
the digraph is not possible and the \textit{schedule set} is not SC.
The compiler can break the cycle under the following conditions:
\begin{itemize}
\item if cycle has some method $M$ \& some rule $R$

              $valid(R)$ \&= $\neg valid(M)$
\item if source code has "priority $R1 > R2$" \& $R1 \in L$ \& $R2 \in L$

              $valid(R2)$ \&= $\neg valid(R1)$
\end{itemize}
If neither of these methods is applicable, the compiler or linker
reports a error, requiring manual resolution in the source program.

Since method/method conflicts in a rule cannot be validated in the absence of
concrete information about their constraints,
this processing is delayed until the "module group binding"
stage of linking, where separately compiled AtomicC output is combined and
verified
for SC scheduling.

\rSec2[atomicc.schedprev]{Previous scheduling work}

In the Esposito Scheduler\cite{Esposito:Patent},
the Bluespec compiler creates a specific, linear schedule, adding
one rule at a time.  When a rule violates constraints from the previously scheduled
rules, an error is issued and an automatic guard is synthesised to prevent the
rule from executing on cycles when conflicting rules are executed.

Since the rules are added to the schedule approximately in the order they are
found in the source program text, the resulting schedule (and which rules are
inhibited) can be affected by source ordering and edits.

\rSec1[atomicc.modcomp]{Compilation}

Modules independently compiled.  Combined with "linking", which validates schedule using header files.

Physical partitioning is used to separate design into separately synthesized pieces, connected using
"long distance" signalling.  Parallel synthesis; bitstreams combined.

AtomicC execution consists of 3 phases:
\begin{itemize}
\item static elaboration: netlist generation, 
\item netlist compilation or implementation
\item and runtime.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist must only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.modfuture]{Future work}

Need to describe multi-cycle rules and pipelining.

Need to have a way to support sequencing of operations

Need to have a way to support model checking (say 'module B is a behavioral description of module A')
Show example with diff eqn solver from Sharp thesis.

C block semantics do not correctly process the 2 statements: a = b; b = a;.
(binding of read values should occur at beginning of block, so that it is clear the
2nd assign refers to the 'previous' value).
Thinking again: if we retain C semantics, we have: temp = a; a = b; b = temp;, which
gives the correct value mapping.

Multiple clock domains
