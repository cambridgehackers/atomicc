%!TEX root = std.tex
\rSec0[atomicc.basic]{Basic}

\rSec1[atomicc.intro]{Introduction}

AtomicC is a timed, structural hardware description language for
the high level specification of algorithms to be instantiated
directly in hardware.
AtomicC extends C++
with Bluespec-style\cite{Bluespec:www,Hoe:Thesis,HoeArvind:TRS_Synthesis2}
modules, rules, interfaces, and methods.

The language is designed for
the construction of \textbf{modules} that are correct-by-construction \textit{composable}:
validated smaller modules can be aggregated to form
a larger validated module with no impact on the correct
operation of the component modules:
\begin{itemize}
\item Modules interactions are performed with Latency Insensitive (LI)
\cite{carloni2001theory}
\textbf{method} calls, automating the transitive effect of stalls.
\item Module behaviorial statements are encapsulated into single cycle transactions (\textbf{rules}),
replacing unreliable manual analysis of parallel operation
with compile time hazard detection and runtime stall logic.
\cite{NikhilSemantics}
\cite{harris2005composable}.
\item Like the Go language\cite{Pike2012},
an \textbf{interface} is a named collection of method signatures, defining
the behavior of an abstract data type(ADT) \cite{Liskov74programmingwith}.
Modules can export multiple, named \textbf{interfaces},
promoting easy composition and coupling with other modules.
AtomicC supports both export and import of interfaces, giving flexibility in
algorithm expression.
\item All state elements in the hardware
netlist are explicit in the source code of the design.
\end{itemize}
These features support the efficient reuse of pre-compiled, incrementally validated
libraries, improving productivity on large designs.

AtomicC does not attempt to emulate the behavior of all C++ constructs in hardware,
instead uses a subset of the C++ language to specify behavioral
assignments to state elements.
Standard C++ templates allow parametric polymorphic reuse of \textbf{modules}.
In AtomicC, all module data is private; an instantiator of a module can only 
interact with it via interface method invocations.

Like Connectal, AtomicC designs may include both hardware and
software components, using interfaces to specify hardware/software communication
in a type safe manner. The AtomicC compiler generates the code and transactors to pass
arguments between hardware and software.

The AtomicC compiler 
generates a single Verilog module for each AtomicC module declared.
Standard Verilog backend tools are then used to synthesize
the resulting ASIC or FPGA.
Integration with existing backend Verilog infrastructure including reuse of existing Verilog
components.

The basic building block of AtomicC is the module declaration.
Modules consist of 3 parts:
\begin{itemize}
\item Instantiation of state elements used by the module,
\item Interface declarations for interacting from other modules,
\item Rules, which group assignment statements and method invocations into atomic transactions.
\end{itemize}

\rSec1[atomicc.interface]{Interfaces}

Exported interfaces can be used in several ways:
\begin{itemize}
\item invoked directly by the instantiator of the module,
\item forwarded transparently, becoming another exported interface of the instantiating module,
\item 'connected' to an 'interface reference' of another module in the instantiating scope.
\end{itemize}

Module interface methods invocations are \textit{stallable}, refered to as \textit{patient system}
\cite{carloni2001theory}.
This allows the called method to enforce invocation pre-conditions on the caller
so that interface usage requirements are guaranteed and stalling is transitive.

There are 2 types of methods:
\begin{itemize}
\item \textbf{Value method functions} provide read-only access to module state elements.
\item \textbf{Action method procedures} perform write operations on state elements,
can take parameters and do not have a return value.
A compiler generated
\textbf{valid} signal indicates that the caller wishes to perform the method invocation.
\end{itemize}

Both types of methods use a compiler generated \textbf{ready} signal
to indicate when the callee is available and
to prevent scheduling of the calling transaction until all necessary elements are
available.

AtomicC uses a \textbf{valid/ready} \textit{hand-shaking signalling}
\cite{Fletcher2009, AXISpec} to invoke action methods,
giving both the invoker(master) and invokee(slave) the ability to control transaction
execution timing.
The master uses the \textbf{valid} signal
of the method to show when parameter data is available and the transaction should be performed.
The method invocation transaction succeeds only when
both \textbf{valid} and \textbf{ready} are HIGH:

 ($\pi(M_{i}) \equiv ready(M_{i})\ \&\&\ valid(M_{i})$).

\rSec1[atomicc.modrule]{Rules}

Transactions are units of consistency (preserving program invariants), following ACID semantics.
In AtomicC, all enabled statements in all modules execute on every clock cycle.
The compiler synthesizes control signals, allowing rules to fire
only when their dependent elements and referenced method invocations are ready.

Scheduling of rules guarantees 'Isolation',
(also called 'consistency', 'concurrency control', 'serializability', or 'locking')
\cite[Sec.~7.1]{GrayR93}.

Grouping operations on state elements into transactions (\textbf{rules})
enables compile time formal verification of the correctness of
parallel execution of transactions
in the synthesized logic.
\cite{nurvitadhi2011automatic}
\cite{fox2003algebraic}

The AtomicC compiler
validates that all rules executed during a given clock cycle are
"sequentially consistent"(SC) \cite{Lamport:1979:MMC:1311099.1311750},
allowing analysis of
outcome of each rule independently of any other rules that could be executing at the same time.

In contrast to software, which uses \textit{dynamic allocation}\cite[p.~377]{GrayR93}
and locking\cite[Sec.~11.2]{OV11} to guarantee isolation,
the set of state elements accessed by an AtomicC transaction are known at compile time.
In addition, the boolean condition when the transaction is performed
is also known, allowing \textit{static allocation}\cite[Sec.~7.3.1]{GrayR93} of schedules.
Unlike lock-based scheduling,
rule are compositional: small transactions can be glued together to form larger transactions.

To check that a set of rules is SC, first
define a dependency digraph with node for each transactions and
dependency arcs from loads to stores.
The transitive closure of these orders on the dependency graph nodes dictate
the sequence in which each operation must \textit{appear} to execute in order to
be considered correct.

A \textit{constraint graph} is a partially-ordered digraph that models
execution of a set of rules.
\cite[Sec.~3]{Cain2003}.
Nodes in a constraint graph represent atomic rule execution instances.  Edges
represent the ordering relations between these instances, and are transitive in nature.
The transitive closure of these orders on the constraint graph nodes
dictate the sequence in which each operation must \textit{appear} to execute in
order to be considered correct.
Dependency constraints are:
\begin{itemize}
\item \textbf{Read-after-write (RAW)}: two nodes are connected by RAW dependence
edges if one transaction creates a value that is used by the other, ensuring
that values are created before they are read.
\item \textbf{Write-after-read (WAR)}: the transaction node that writes a state
element is preceded by a node that reads that element.
\item \textbf{Write-after-write (WAW)}: the transaction node that writes a state
element is preceeded by another node that has previously written that element.
\end{itemize}
Currently in AtomicC, only WAR edges are permitted, since all reads
of state elements occur at the beginning of a clock period (preventing RAW)
and all writes occur at the end (preventing WAW).
In the future, it is possible that RAW edges can be removed using value prediction.

A set is SC if and only if the dependency digraph is acyclic.

$O[i] \cap (I[j] \cup O[j]) = \varnothing, \forall i \neq j $
\cite[Sec.~7.3]{GrayR93}

\rSec1[atomicc.schedule]{Scheduling}

Each rule has a set of state elements that it reads and another set of element that it writes.
Value method invocations are treated as reads; action method invocations are treated as writes.
For the execution of a group of rules to be considered to be SC, the following must
be true:
\begin{itemize}
\item Atomic: All read and write operations for a given rule occur at the same time point in the sequence.
\item Read-before-write:  A rule that writes a state element must occur later in the sequence
than any rules that read the same state element.
\item Non-conflicting: A given state element cannot be written by more than one concurrently executable rule.
\end{itemize}

The compiler statically determines the 'read' and 'write'
footprint for every rule and method \cite[Sec.~10.1.2]{OV11} \cite{doi:10.1137/0213032}.
\begin{itemize}
\item read set: $R_{i}.read$
\item write set: $R_{i}.write$
\item base set: $S(R_{i}) \equiv R_{i}.read \cup R_{i}.write$
\end{itemize}
\cite[Sec.~10.1.2]{OV11}
\cite[Sec.~11.1]{OV11}  2 operations on same state element (x) are in conflict if
one of them is a write. -> partial order)

The compiler and linker do not resolve SC conflicts automatically.
If static compile analysis cannot prove that their execution conditions(guards) or
effects(base sets) are always disjoint,
then the source text of the program must specify the priority order of scheduling
to resolve conflicts.

\rSec2[atomicc.schedalg]{Algorithm}
\begin{itemize}
\item arc condition: $arcCond(uv) \equiv
\newline
      fold (|, \{ \forall E \in u.Write, E \in v.Read \colon (u.Write(E).cond\ \&\ v.Read(E).cond) \})$
\end{itemize}

\begin{lstlisting}[mathescape=true]
$WorkSet$ = { all rules and methods for module }
for $r \in WorkSet$ do
    // Greedily group all rules/methods that have some overlap in read/write sets
    $V = \{ r \}$
    $V = \{ E \vert S(E) \cap S(V) \neq \varnothing  \}$  // Create next schedule set
    $WorkSet = WorkSet \setminus V$

    // Create 'read-before-write' dependency digraph
    $G = (V, E)$
    where: 
       $V$ is a set of vertices
       $E$ is a set of arcs $==$ { uv $\vert$ arcCond(uv) is not identically false }

    // Find loops
    $L$ = loops in $G$

    for $L \in G$ do
       if fold (&, { $\forall uv \in L \colon$ arcCond(uv)}) is not identically false
          // 'break' loop L
          if loop has some method $M$ & some rule $R$
              $valid(R)$ &= $\neg valid(M)$
          else if source code has "priority $R1 > R2$" & $R1 \in L$ & $R2 \in L$
              $valid(R2)$ &= $\neg valid(R1)$
          else
              dependency digraph not acyclic, report error
\end{lstlisting}

\rSec2[atomicc.schedlink]{Linking}

Without knowledge of the internals of a method, it must be assumed that all "action method"
calls to a state element conflict.  In addition, it must be assumed that all "value method" calls
must preceed all "action method" calls in any clock cycle.

Since method/method conflicts in a module cannot be validated in the absence of
information about their usage, this processing is delayed until the "module group binding"
stage of linking.
(It is not possible to resolve these conflicts standalone in the instantiated module.)

The linker cannot break any loops, but can only report on errors that are non-DAG.

Memoize checked results.

\rSec2[atomicc.schedfuture]{Future directions in scheduling}

It is possible to create new rules that 'read' the 'commit value' for a state element.
This would be done by synthesising a new 'combined rule' and scheduling it \cite{Rosenband:Thesis}.

\rSec2[atomicc.schedprev]{Previous scheduling work}

In the Esposito Scheduler\cite{Esposito:Patent},
the Bluespec compiler creates a specific, linear schedule, adding
one rule at a time.  When a rule violates constraints from the previously scheduled
rules, an error is issued and an automatic guard is synthesised to prevent the
rule from executing on cycles when conflicting rules are executed.

Since the rules are added to the schedule approximately in the order they are
found in the source program text, the resulting schedule (and which rules are
inhibited) can be affected by source ordering and edits.

\rSec1[atomicc.modcomp]{Compilation}

The AtomicC compiler generates a separate Verilog module definition
for each source AtomicC module definition.
This verilog source defines the state elements
used in the design as well as their connections (netlist).

Modules independently compiled.  Combined with "linking", which validates schedule using header files.

Physical partitioning is used to separate design into separately synthesized pieces, connected using
"long distance" signalling.  Parallel synthesis; bitstreams combined.

AtomicC execution consists of 3 phases:
\begin{itemize}
\item static elaboration: netlist generation, 
\item netlist compilation or implementation
\item and runtime.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist must only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.modfuture]{Future work}

Need to describe multi-cycle rules and pipelining.

Need to have a way to support sequencing of operations

Need to have a way to support model checking (say 'module B is a behavioral description of module A')
Show example with diff eqn solver from Sharp thesis.

C block semantics do not correctly process the 2 statements: a = b; b = a;.
(binding of read values should occur at beginning of block, so that it is clear the
2nd assign refers to the 'previous' value).
Thinking again: if we retain C semantics, we have: temp = a; a = b; b = temp;, which
gives the correct value mapping.

Multiple clock domains
