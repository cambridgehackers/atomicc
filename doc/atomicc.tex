%!TEX root = std.tex
\rSec0[atomicc.basic]{Basic}

\rSec1[atomicc.intro]{Introduction(alt)}

AtomicC is a structural hardware description language, permitting
the high level specification of algorithms to be instantiated
directly in hardware.
AtomicC is a timed HDL and all state elements in the hardware
netlist are explicit in the source code of the design.
Separate compilation of modules promotes the safe use of pre-compiled, validated
libraries, improving productivity on large projects.

AtomicC extends C++
with Bluespec-style\cite{Bluespec:www,Hoe:Thesis,HoeArvind:TRS_Synthesis2}
modules, rules, interfaces, and methods.
AtomicC does not attempt to emulate the behavior of all C++ constructs in hardware.
Instead, it uses the C++ source text to specify the desired
single static assignment(SSA) computations,
performing these computations under an atomic rule-based execution model.
In addition, an interface definition scheme is used to explicitly and flexibly
manage the visibility of interface methods to a module.

Like Connectal, AtomicC designs may include both hardware and
software, using interfaces to specify hardware/software communication
in a type safe way. The AtomicC compiler generates the code and transactors to pass
arguments between hardware and software.

\rSec3[atomicc.mod]{Modules}
The basic building block of AtomicC is the module declaration.
AtomicC module definitions consist of 3 parts:
1) instantiation of modules for state elements used internally by the module,
2) the module's interface for interacting with other modules.
and 3) 'rules', which group conditional assignment statements and method invocations into atomic transactions.

Instatiated modules are interacted with through their interface methods.  The parameters
to these methods are used to conditionally pass data to the instantiated module.
The 'invocation' of the method communicates to the module that the associated
data parameters are valid and to execute the text of the method.
The 'invoked' method is able to hold off invocation by the caller.
To associate 'ready' ('able to be invoked')
and 'valid' ('invoke on next cycle'), AtomicC uses module 'method' to connect data
and control signals.

An interface is a list of method signatures, but no method bodies, defining
a abstract data type(ADT)\cite{Liskov74programmingwith} for the module.
Named interface declarations allows multiple ADTs to be defined for
the module and an explicit denotation of which ADTs are connected to other
state elements in the program text.
AtomicC follows in the tradition of the Go language \cite{Pike2012},
promoting the use of interfaces when performing composition and
coupling rather than using inheritance.  Assembling (composing) a solution
to your problem using structural composition of building blocks
is both easy to write and maintain.

A 'method invocation' style syntax indicates when data ports to module
are valid and when commit transactions on interfaces should be performed.
Implicit ready signalling from the called module allows it to prevent
scheduling of the calling transaction until all necessary elements are
available.

2 types of methods: 1) "Action".  Return void. Have parameters, ready, valid; 2) "Value". Return value, have ready.

A module can declare named interface elements and then provide implementations of
the methods of each of these interfaces.  A module definition can also declare
elements that are 'interface reference's, allowing the module to invoke methods
in an external module.
Named interfaces elements can be: 1)referenced by the instantiator of the module,
2) forwarded transparently as an interface for the instantiating module or 3) 'connected'
to an 'interface reference' of another module in the instantiating scope.

\rSec3[atomicc.modrule]{Rules}
Atomic actions (rules and method invocations) execute in a single clock cycle.
In AtomicC, all enabled statements in all modules execute on every clock cycle.

Rules execute as atomic transactions: internal states in the rule
execution are not visible to other rules.  In addition, although all enabled
rules execute every cycle, their execution must be 
"equivalent" to some legal sequential computation.
\cite{Lamport:1979:MMC:1311099.1311750}
The AtomicC compiler verifies that it is valid to consider
all rules executed during a given clock cycle
as if they were serialized into a linear, atomic ordering ("sequentially consistent"(SC)).
Even though all concurrent rules are executed during the same clock cycle, SC allows us to compute the
outcome of each rule independantly of any other rules that could be executing at the same time.

If static compile analysis cannot prove that their execution is disjoint
or the source text of the program must specify the priority order of execution
when both rules are valid,
then two rules are not serializable (they have a 'read' or a 'write' conflict).
Note that there is no 'fair' scheduling: on each cycle, the higher priority valid rule will
always be executed.

Since there are no pointers, the compiler can statically determine the 'read' and 'write'
footprint for every statement, allowing automated verification and
synthesis of logic to prevent concurrency conflicts.

Automated synthesis of scheduling signals in the modular design
decreases the analytic burden on the engineer; compile-time analysis
detects all errors where serializable execution of transactions cannot be guaranteed.

The compiler automatically synthesizes control signals that allow rules to fire
only when their dependant elements are ready and when there are no conflicts with
other rules executing in the same cycle.  The removal of this analytic burden on
the engineer increases productivity as well as improves reliability of the
resulting design.

"Scheduling" ensures SC guarantee.

\rSec3[atomicc.modcomp]{Compilation}

The AtomicC compiler generates a separate Verilog module definition
for each source AtomicC module definition.
This verilog source defines the state elements
used in the design as well as their connections (netlist).

Modules independently compiled.  Combined with "linking", which validates schedule using header files.

Physical partitioning is used to separate design into separately synthesized pieces, connected using
"long distance" signalling.  Parallel synthesis; bitstreams combined.

AtomicC execution consists of 3 phases:
\begin{itemize}
\item netlist generation, 
\item netlist compilation or implementation
\item and runtime.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist must only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.prev]{Previous work}

AtomicC derives heavily from and is based upon the language Bluespec Verilog (BSV)
and the experiences of the BSV community.  Although the responsibility for all
errors in AtomicC lie solely with the current authors, the underlying analysis and
concepts come from 20 years of accumulated research in this area that community.

In the Esposito Scheduler\cite{Esposito:Patent},
the Bluespec compiler creates a linear schedule, adding
one rule at a time.  When a rule violates constraints from the previously scheduled
rules, an error is issued and an automatic guard is synthesised to prevent the
rule from executing on cycles where conflicting rules are executing.

Since the rules are added to the schedule approximately in the order they are
found in the source program text, the resulting schedule (and which rules are
inhibited) can be affected by source ordering and edits.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\rSec1[atomicc.schedule]{Scheduling}

Each rule has a set of state elements that it reads and another set of element that it writes.
For the execution of a group of rules to be considered to be SC, the following must
be true:

\begin{itemize}
\item Atomic: All read and write operations for a given rule occur at the same time point in the sequence.
\item Read-before-write:  A rule that writes a state element must occur later in the sequence
than any rules that read the same state element.
\item Non-conflicting: A given state element cannot be written by more than one concurrently executable rule.
\end{itemize}

The compiler and linker do not break SC violations automatically. Error require the user to annotate
the source text with "priority" statements to resolve conflicts.

\rSec2[atomicc.scheddefs]{Definitions}
\begin{itemize}
\item Rules: $R_{i}$
\item Methods: $M_{i}$
\item Control signals:
\begin {itemize}
\item Exported signal(generated by callee):  $ready(M_{i})$
\item Imported signal(generated by caller):  $valid(M_{i})$
\end{itemize}
\item Rule firing condition: $\pi(M_{i}) \equiv ready(M_{i})\ \&\&\ valid(M_{i})$
\item read set: $R_{i}.read$
\item write set: $R_{i}.write$
\item sensitivity set: $S(R_{i}) \equiv R_{i}.read \cup R_{i}.write$
\item schedule set: all rules that could possibly conflict (rules that share elements in sensitivity set)
\end{itemize}

\rSec2[atomicc.schedalg]{Algorithm}

\begin{lstlisting}[mathescape=true]
// Partition rules into disjoint "schedule sets"
U = { $R_{i}, M_{i}$ forall i }   // Construct set of unscheduled rules and methods for this module
While $U \neq \emptyset$           // While there are unscheduled rules/methods
    Extract a rule, T, from U
    $P_{i} = \{ T \}$          // Create next schedule set
    forall E in U
        if $S(E) \cap S(P_{i}) \neq \emptyset$
            Move E from U to $P_{i}$
    // Create 'read-before-write' graph
    Initialize graph G to have nodes for all elements in $P_{i}$
    forall T in $P_{i}$
        forall W in T.write
            forall J in $P_{i}$
                forall R in J.read
                    if W.name == R.name
                        add arc [$T \Rightarrow J$; guard: $(W.cond\ \&\&\ R.cond\ \&\&\ \pi(T)\ \&\&\ \pi(J))$]
    // Check/repair 'read-before-write' graph to be SC
    forall loops L in G
       loopcondition = true
       forall arcs A in L 
          loopcondition = loopcondition & A.guard
       if loopcondition is not identically false
          if loop has some method $M_{i}$ and some rule $R_{j}$
              $ready(R_{j}) = ready(R_{j})\ \&\&\ \neg \pi(M_{i})$
          else if source code has "priority $R_{i} > R_{j}$" & $R_{i}$ in L & $R_{j}$ in L
              $ready(R_{j}) = ready(R_{j})\ \&\&\ \neg \pi(R_{i})$
          else
              loop still exists, report error
\end{lstlisting}

