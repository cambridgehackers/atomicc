%!TEX root = std.tex
\rSec0[atomicc.intro]{Introduction}

AtomicC is a structural hardware description language that extends C++
with Bluespec-style modules, rules, interfaces, and methods.

AtomicC is structural in that all state elements in the hardware
netlist are explicit in the source code of the design. AtomicC is a
timed HDL, using SystemC terminology. 
Atomic actions (rules and method invocations) execute in a single clock cycle.

To permit reasonable analysis of the program behavior, rules (transactions) can only be
executed in a "sequentially consistent" manner.  Since concurrent rules are all executed in a
single clock cycle, in practice this means that we have to prove at compilation time that
all possible executions can always be considered as some linear sequentially ordered instantiation
within a cycle.

Like Connectal, AtomicC designs may include both hardware and
software, using interfaces to specify hardware/software communication
in a type safe way. The AtomicC compiler generates the code to pass
arguments between hardware and software.

AtomicC execution consists of 3 phases:
\begin{itemize}
\item netlist generation, 
\item netlist compilation or implementation
\item and runtime.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist may only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.execution]{Execution Semantics}

\rSec2[atomicc.execution]{Execution control}

\rSec3[atomicc.readyEnable]{Asymmetric (ready/enable signalling)}
A method/rule is invoked by asserting the "enable" signal.  This signal can only be
asserted if the "ready" signal was valid, allowing the called module to restrict
permissible execution sequences.

\rSec3[atomicc.readyValid]{Symmetric (ready/valid signalling)}
Both caller/callee have "able to be executed" signals.  Execution is deemed to take
place in each cycle where both "ready" (from the callee) and "valid" (from the caller)
are asserted.

\rSec2[atomicc.schedule]{Scheduling}
Each rule has a set of state elements that it reads and another set of element that it writes.
Valid sequential orderings require that every state element must be logically read before it is logically
written ("read before write").

Scheduling is done by building a graph:
\begin{itemize}
\item Nodes are rules/guards within a module.
\item For all state elements, insert a directed links from each node that writes the state element to every node that reads it.
\end{itemize}

Cycles can be broken in 2 ways:
\begin{itemize}
\item Rules default to have lower priority than methods within a module.  If the designer wants the rule to take precedence, a "priority" statement can be specified.
\item "priority" statements in source text can be used to break cycles, if necessary.
\end{itemize}

To permit rule scheduling to be dependent on the "enable" signals of methods and other rules, rules use "ready/valid" scheduling.

\rSec1[atomicc.printf]{debugging with printf}

To aid debugging with a simulator, "printf" statements in __module declarations are
translated to "\$display" statements in the generated verilog.
For debugging with synthesized hardware, "printf" statements are translated into
indication packets sent through the NOC back to the software side host program.
The format strings for the printf statements are placed into a generated file
in generated/xxx.generated.printf along with a list of the bit lengths for each
parameter to the printf.

To use the NOC printf:
\begin{itemize}
\item add the following line to the __module being tested: __printf;
\item add a line similar to the following (with the 'xxx' replaced) to the test program:
           atomiccPrintfInit("generated/rulec.generated.printf");
\end{itemize}

\rSec1[atomicc.command]{Command line switches}
Command line switches...
