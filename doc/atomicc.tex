%!TEX root = std.tex
\rSec0[atomicc.basic]{Basic}

\rSec1[atomicc.intro]{Introduction}

AtomicC is a timed, structural hardware description language for
the high level specification of algorithms to be instantiated
directly in hardware.
AtomicC extends C++
with support for Guarded Atomic Actions
\cite{Hoe:Thesis,HoeArvind:TRS_Synthesis2}:
Bluespec-style\cite{Bluespec:www}
modules, rules, interfaces, and methods.
AtomicC does not attempt to emulate the behavior of all C++ constructs in hardware,
instead uses a subset of the C++ language to specify behavioral
assignments to state elements.

The language is designed for
the construction of \textbf{modules} that are correct-by-construction \textit{composable}:
validated smaller modules can be aggregated to form
a larger validated module with
no degradation of the component modules:
\begin{itemize}
\item Modules interactions are performed with Latency Insensitive (LI)
\cite{carloni2001theory}
\textbf{method} calls, allowing methods to enforce invocation pre-conditions
and transitive support for stalling.
\item Module behaviorial statements are encapsulated into transactions (\textbf{rules})
following ACID semantics
\cite{NikhilSemantics,GrayR93}.
%% harris2005composable, nurvitadhi2011automatic,fox2003algebraic
The compiler synthesizes control signals, allowing rules to fire
only when their referenced method invocations are ready.

In AtomicC, all enabled rules in all modules execute on every clock cycle.
The compiler
validates that rules executed during a given clock cycle are
"sequentially consistent"(SC) \cite{Lamport:1979:MMC:1311099.1311750},
guaranteeing each rule executes
independently of any other rules executing at the same time
(\textit{isolation}\cite[Sec.~7.1]{GrayR93}).
\item An \textbf{interface} is a named collection of method signatures, defining
the behavior of an abstract data type(ADT) \cite{Liskov74programmingwith}.
Modules can export and import
multiple, named \textbf{interfaces},
giving flexibility in coupling with other modules and in algorithm expression.
\item All state elements in the hardware
netlist are explicit in the source code of the design.
All module data is private to the module, accessable externally only by method invocation.
\end{itemize}
These features support the reliable reuse of pre-compiled, incrementally validated
libraries, improving productivity on large designs.

Like Connectal, AtomicC designs may include both hardware and
software components, using interfaces to specify hardware/software communication
in a type safe manner. The AtomicC compiler generates the code and transactors to pass
arguments between hardware and software.

The AtomicC compiler 
generates a single Verilog module for each AtomicC module declared.
Existing Verilog modules can be called from and can call AtomicC
generated modules.
Standard Verilog backend tools are used to synthesize
the resulting ASIC or FPGA.

The basic building block of AtomicC is the module declaration, made of 3 parts:
\begin{itemize}
\item Instantiation of state elements used by the module,
\item Interface declarations for interacting from other modules,
\item Rules, which group assignment statements and method invocations into atomic transactions.
\end{itemize}

\rSec1[atomicc.interface]{Interface Methods}

There are 2 types of methods:
\begin{itemize}
\item \textbf{Value method functions} provide read-only access to module state elements.
\item \textbf{Action method procedures} perform write operations on state elements,
can take parameters and do not have return values.
A compiler generated
\textbf{valid} signal indicates that the caller wishes to perform the method invocation.
\end{itemize}

Both value and action methods use a compiler generated \textbf{ready} signal
to indicate when the callee is available and
prevent scheduling of the calling transaction until all necessary elements are
available.

AtomicC uses a \textbf{valid/ready} \textit{hand-shaking signalling}
\cite{Fletcher2009, AXISpec} to invoke action methods,
giving both the invoker(master) and invokee(slave) the ability to control transaction
execution timing.
The master uses the \textbf{valid} signal
of an action method to show when parameter data is available
and the operation should be performed.
The method invocation transaction succeeds only when
both \textbf{valid} and \textbf{ready} are HIGH:

 ($\pi(M_{i}) \equiv ready(M_{i})\ \wedge valid(M_{i})$).

\rSec2[atomicc.schedule]{Scheduling}

To guarantee transaction isolation in software, \textit{dynamic allocation}\cite[p.~377]{GrayR93}
and locking\cite[Sec.~11.2]{OV11} are used.
In contrast in AtomicC, the set of state elements accessed by an AtomicC transaction,
the operations on these state elements
and the boolean condition when the transaction is performed
are all known at compile time.
This allows \textit{static allocation}\cite[Sec.~7.3.1]{GrayR93} of \textbf{schedules}
(valid sequences of transaction execution)
and compile time validation of SC.
The scheduling algorithm is:
\begin{itemize}
\item Rules and methods that overlap usage of state elements
(\textit{read set} and \textit{write set}\cite[Sec.~10.1.2]{OV11} \cite{RosenkrantzSternsLewis})
are greedily gathered into \textit{schedule sets} and will be independently scheduled (since
there can be no interactions between sets).
\item A \textit{constraint graph} is a partially-ordered digraph modeling
the dependencies within a \textit{schedule set}:
nodes in a constraint graph represent atomic rule and method instances, edges
represent \textbf{write-after-read (WAR)} ordering dependency
(for a specific storage element)
between instances\cite[Sec.~3]{Cain2003}.
Each edge has a symbolic boolean \textit{edge condition} for when the
the ordering dependency actually exists: the boolean
condition when one rule actually reads a given state element
and another rule actually writes it.

\item The transitive closure of these orders on the constraint graph nodes
dictate the \textbf{schedule} in which each rule must \textit{appear} to execute in
order to be considered SC
\cite[Sec.~11.1]{OV11}.
Of course, since all rules execute in a single cycle, "schedule" does not
refer to an actual time sequenced evolution of state,
but to a \textit{conceptual} "sub-cycle" ordering.

\item For each pair of nodes in the constraint digraph, we define the \textit{node condition}
between 2 nodes as the conjunction of the \textit{edge conditions} of all the edges between
them (i.e., the condition that \textit{any} of the edges causes a dependency).
For each cycle in the digraph, we define the \textit{path condition}
as the disjunction of the \textit{node conditions} for all sequential pairs of nodes
in the cycle (i.e., the condition that \textit{all} the edges, hence the cycle exists).

\item When the \textit{path condition} is not identically false, a total ordering of
the digraph can not be guaranteed and the \textit{schedule set} is not SC.
In this case, the compiler or linker reports an error,
requiring resolution by the user.
\end{itemize}

The compiler can break the cycle under the following conditions:
\begin{itemize}
\item if cycle has some method $M$ \& some rule $R$, then
rewrite the term $valid(R)$ to add a disjunction with the term $\neg valid(M)$
\item if source code has "priority $R1 > R2$" and $R1$, $R2$ are in the cycle, then
rewrite the term $valid(R2)$ to add a disjunction with the term $\neg valid(R1)$
\end{itemize}

Since method invocation conflicts in rules cannot be validated in the absence of
concrete information about the constraints within the methods,
this processing is delayed until the "module group binding"
stage of linking, where separately compiled AtomicC output is combined and
verified
for SC scheduling.

\rSec2[atomicc.schedprev]{Previous scheduling work}

In the Esposito Scheduler\cite{Esposito:Patent},
the Bluespec compiler creates a specific, linear schedule, adding
one rule at a time.  When a rule violates constraints from the previously scheduled
rules, an error is issued and an automatic guard is synthesised to prevent the
rule from executing on cycles when conflicting rules are executed.

Since the rules are added to the schedule approximately in the order they are
found in the source program text, the resulting schedule (and which rules are
inhibited) can be affected by source ordering and edits.

\rSec1[atomicc.modcomp]{Compilation}

Modules independently compiled.  Combined with "linking", which validates schedule using header files.

Physical partitioning is used to separate design into separately synthesized pieces, connected using
"long distance" signalling.  Parallel synthesis; bitstreams combined.

AtomicC execution consists of 3 phases:
\begin{itemize}
\item static elaboration: netlist generation, 
\item netlist compilation or implementation
\item and runtime.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist must only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.modfuture]{Future work}

Need to describe multi-cycle rules and pipelining.

Need to have a way to support sequencing of operations

Need to have a way to support model checking (say 'module B is a behavioral description of module A')
Show example with diff eqn solver from Sharp thesis.

C block semantics do not correctly process the 2 statements: a = b; b = a;.
(binding of read values should occur at beginning of block, so that it is clear the
2nd assign refers to the 'previous' value).
Thinking again: if we retain C semantics, we have: temp = a; a = b; b = temp;, which
gives the correct value mapping.

Multiple clock domains
