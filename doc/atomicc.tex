%!TEX root = std.tex
\rSec0[atomicc.basic]{Basic}

\rSec1[atomicc.intro]{Introduction}

AtomicC is a timed, structural hardware description language, permitting
the high level specification of algorithms to be instantiated
directly in hardware.

The language is designed for
the construction of \textbf{modules} that are \textit{composable}:
validated smaller modules can be aggregated to form
a larger validated module with no impact on the correct
operation of the component modules.
\begin{itemize}
\item Modules interactions are performed with Latency Insensitive (LI) \textbf{method} calls, allowing automated handling of the transitive effect of stalls.
\item Module behaviorial statements are encapsulated in transactions (\textbf{rules}), allowing static validation of correct operation in the presence of concurrent execution.
\item Modules can export multiple, explicitly named Abstract Data Type (ADT) \textbf{interfaces},
promoting flexibility and clarity in module coupling.
\item All state elements in the hardware
netlist are explicit in the source code of the design, removing a source of common errors.
\item Parametric polymorphic data types allow flexible reuse of parameterized
\textbf{modules} (C++ templates).
\item Integration with existing backend Verilog infrastructure including reuse of existing Verilog
components.
\end{itemize}
This supports the efficient, incremental reuse of pre-compiled, validated
libraries, improving productivity on large designs.

\rSec2[atomicc.imethod]{Latency Insensitive Methods}
Automate the handling of the transitive effect of stalls.

Latency-Insensitive Design assumes that modules are stallable.
In future designs, a signal will need more than 10 clock cycles
to traverse the entire chip area.  Partition long wires into
subsections, connected with relay stations.
Can be implemented using \textit{hand-shaking signalling} techniques.
(Carloni, McMillan, SangiovanniVincentelli)

A patient system is one whose components are \textit{stallable}.
Two signals are latency equiv if they present the same sequence of
informative events.
Patient process: 1) intersection of 2 patient processes is a patient
process, 2) give 2 pairs of latency equiv patient processes,
their pairwise intersections are also latency equiv.

\rSec2[atomicc.itrans]{Transactions}

Grouping operations into transactions (\textbf{rules})
enable compile time formal verification of the correctness of
composite parallel execution of transactions
in the synthesized logic.

Use of transactions supports compositions of modules that 
retain atomic properties.  (usually atomic ops are non-modular, non-compositional
HarrisMarlowJonesHerlihy, Nikhil)
Transactions are compositional: small transactions can be glued together to form 
larger transactions(HarrisMarlowJonesHerlihy).
Lock-based programs do not compose: correct fragments may fail when composed.

Transactional Datapath Specification.  (Nurvitadhi)
To support overlapped execution of multiple operations,
hazard detection and stall logic is introduced to maintain
the correctness of operations in the overlapped executions.
The single-cycle version serves as a function specification of the pipelined
design, used in model checking.
T-spec blocks use an established set of handshaking signals: ready, start, done.
Each async block can be executed at most once by each transaction.

Time is defined relative to state transition and not the other way around.
(FoxHarman)

\rSec2[atomicc.iinterface]{Interface}
AtomicC follows in the tradition of the Go language\cite{Pike2012},
promoting the use of \textbf{interfaces} for composition and
coupling rather than (possibly multiple) inheritance.
An ADT is "a way to interact with a module" rather than "a description
of the module type itself".

\rSec2[atomicc.imodule]{Module}

The AtomicC compiler 
generates a single Verilog module for each AtomicC module declared.
Standard Verilog backend tools are then used to synthesize
the resulting ASIC or FPGA.

AtomicC extends C++
with Bluespec-style\cite{Bluespec:www,Hoe:Thesis,HoeArvind:TRS_Synthesis2}
modules, rules, interfaces, and methods.
AtomicC does not attempt to emulate the behavior of all C++ constructs in hardware.
Instead, it uses a subset of the C++ language to specify desired
conditional assignments to state elements,
performing these operations under an atomic transaction rule-based execution model.
In AtomicC, all module data is private; an instantiator of a module can only 
interact with it via interface method invocations.

Like Connectal, AtomicC designs may include both hardware and
software components, using interfaces to specify hardware/software communication
in a type safe manner. The AtomicC compiler generates the code and transactors to pass
arguments between hardware and software.

The basic building block of AtomicC is the module declaration.
Modules consist of 3 parts:
\begin{itemize}
\item Instantiation of state elements used by the module,
\item Interface declarations for interacting from other modules,
\item Rules, which group assignment statements and method invocations into atomic transactions.
\end{itemize}

\rSec1[atomicc.interface]{Interfaces}
Instantiated modules are interacted with using one or more interfaces exported by the module.
An interface definition is a list of method signatures, but no method bodies, defining
an abstract data type(ADT) \cite{Liskov74programmingwith} view exported by the module.
Module interfaces are named, 
allowing explicit denotation in the program text
of which module ADTs are connected to and accessable from other state elements.
In addition to defining and exporting interfaces,
a module definition can also import
interface references, exported from an
externally defined module, providing flexibility in algorithmic description.

Exported interfaces can be used in several ways:
\begin{itemize}
\item invoked directly by the instantiator of the module,
\item forwarded transparently, becoming another exported interface of the instantiating module,
\item 'connected' to an 'interface reference' of another module in the instantiating scope.
\end{itemize}

\rSec1[atomicc.method]{Interface Methods}
There are 2 types of methods:
\begin{itemize}
\item \textbf{Value method functions} provide read-only access to module state elements.
\item \textbf{Action method procedures} perform transactions on state elements
and do not have a return value.
Parameters are used to pass transaction data to the instantiated module.
A compiler generated
\textbf{valid} signal indicates that the caller wishes to perform the method invocation.
\end{itemize}

Both types of methods use a compiler generated \textbf{ready} signal
to indicate when the callee is available and
to prevent scheduling of the calling transaction until all necessary elements are
available.

AtomicC uses a \textbf{valid/ready} handshake process\cite{Fletcher2009, AXISpec} to invoke action methods,
giving both the invoker(master) and invokee(slave) the ability to control execution timing.
The master uses the \textbf{valid} signal
of the method to show when parameter data is available and the transaction should be performed
The method invocation transaction succeeds only when
both \textbf{valid} and \textbf{ready} are HIGH ($\pi(M_{i}) \equiv ready(M_{i})\ \&\&\ valid(M_{i})$).

\rSec1[atomicc.modrule]{Rules}

Operations on state elements are grouped into transactions, called \textbf{rules}.
Transactions are units of consistency (preserving program invariants), following ACID semantics.
In AtomicC, all enabled statements in all modules execute on every clock cycle.
The compiler synthesizes control signals, allowing rules to fire
only when their dependent elements and referenced method invocations are ready.

Scheduling of rules guarantees 'Isolation',
also called 'consistency' (the static property), 'concurrency control'
(the problem), 'serializability' (the theory), or 'locking' (the technique). (\cite{GrayR93}, Sec 7.1)

In contrast to software, which uses \textit{dynamic allocation} and locking to guarantee isolation
\cite[p.~377]{GrayR93} \cite[Sec.~11.2]{OV11},
state elements accessed by an AtomicC transaction are known at compile time as well as the
conditions when the transaction is performed.  This allows \textit{static allocation}
\cite[Sec.~7.3.1]{GrayR93} of schedules.

The AtomicC compiler
validates that all rules executed during a given clock cycle are "equivalent"
to some linear, atomic ordering ("sequentially consistent"(SC))
\cite{Lamport:1979:MMC:1311099.1311750}.
Even though all concurrent rules are executed during the same clock cycle,
SC allows us to compute the
outcome of each rule independently of any other rules that could be executing at the same time.

There is a graph-based definition of SC: define a constraint graph with node for each load/store.
protocol is SC iff all traces have acyclic constraint (also called precedence) directed graphs
\cite{Cain2003}.
The transitive closure of these orders on the constrain graph nodes dictate
the sequence in which each operation must \textit{appear} to execute in order to
be considered correct.
Dependency constraints(RAW, WAR, WAW) vs consistency constraints (defined by memory consistency model.  for example, if model is SC, then directed cycle cannot be placed in total order).
WAR/WAW edges can be removed using register renaming.  RAW edges
can be removed using value prediction.

$O[i] \cap (I[j] \cup O[j]) = \varnothing, \forall i \neq j $
\cite[Sec.~7.3]{GrayR93}

\rSec1[atomicc.schedule]{Scheduling}

Each rule has a set of state elements that it reads and another set of element that it writes.
Value method invocations are treated as reads; action method invocations are treated as writes.
For the execution of a group of rules to be considered to be SC, the following must
be true:
\begin{itemize}
\item Atomic: All read and write operations for a given rule occur at the same time point in the sequence.
\item Read-before-write:  A rule that writes a state element must occur later in the sequence
than any rules that read the same state element.
\item Non-conflicting: A given state element cannot be written by more than one concurrently executable rule.
\end{itemize}

The compiler statically determines the 'read' and 'write'
footprint for every rule and method \cite[Sec.~10.1.2]{OV11} \cite{doi:10.1137/0213032}.
\begin{itemize}
\item read set: $R_{i}.read$
\item write set: $R_{i}.write$
\item base set: $S(R_{i}) \equiv R_{i}.read \cup R_{i}.write$
\end{itemize}
\cite[Sec.~10.1.2]{OV11}
\cite[Sec.~11.1]{OV11}  2 operations on same state element (x) are in conflict if
one of them is a write. -> partial order)

The compiler and linker do not resolve SC conflicts automatically.
If static compile analysis cannot prove that their execution conditions(guards) or
effects(base sets) are always disjoint,
then the source text of the program must specify the priority order of scheduling
to resolve conflicts.

\rSec2[atomicc.schedalg]{Algorithm}
\begin{itemize}
\item arc condition: $arcCond(uv) \equiv
\newline
      fold (|, \{ \forall E \in u.Write, E \in v.Read \colon (u.Write(E).cond\ \&\ v.Read(E).cond) \})$
\end{itemize}

\begin{lstlisting}[mathescape=true]
$WorkSet$ = { all rules and methods for module }
for $r \in WorkSet$ do
    // Greedily group all rules/methods that have some overlap in read/write sets
    $V = \{ r \}$
    $V = \{ E \vert S(E) \cap S(V) \neq \varnothing  \}$  // Create next schedule set
    $WorkSet = WorkSet \setminus V$

    // Create 'read-before-write' constraint digraph
    $G = (V, E)$
    where: 
       $V$ is a set of vertices
       $E$ is a set of arcs $==$ { uv $\vert$ arcCond(uv) is not identically false }

    // Find loops
    $L$ = loops in $G$

    for $L \in G$ do
       if fold (&, { $\forall uv \in L \colon$ arcCond(uv)}) is not identically false
          // 'break' loop L
          if loop has some method $M$ & some rule $R$
              $valid(R)$ &= $\neg valid(M)$
          else if source code has "priority $R1 > R2$" & $R1 \in L$ & $R2 \in L$
              $valid(R2)$ &= $\neg valid(R1)$
          else
              constraint digraph not acyclic, report error
\end{lstlisting}

\rSec2[atomicc.schedlink]{Linking}

Without knowledge of the internals of a method, it must be assumed that all "action method"
calls to a state element conflict.  In addition, it must be assumed that all "value method" calls
must preceed all "action method" calls in any clock cycle.

Since method/method conflicts in a module cannot be validated in the absence of
information about their usage, this processing is delayed until the "module group binding"
stage of linking.
(It is not possible to resolve these conflicts standalone in the instantiated module.)

The linker cannot break any loops, but can only report on errors that are non-DAG.

Memoize checked results.

\rSec2[atomicc.schedfuture]{Future directions in scheduling}

It is possible to create new rules that 'read' the 'commit value' for a state element.
This would be done by synthesising a new 'combined rule' and scheduling it \cite{Rosenband:Thesis}.

\rSec2[atomicc.schedprev]{Previous scheduling work}

In the Esposito Scheduler\cite{Esposito:Patent},
the Bluespec compiler creates a specific, linear schedule, adding
one rule at a time.  When a rule violates constraints from the previously scheduled
rules, an error is issued and an automatic guard is synthesised to prevent the
rule from executing on cycles when conflicting rules are executed.

Since the rules are added to the schedule approximately in the order they are
found in the source program text, the resulting schedule (and which rules are
inhibited) can be affected by source ordering and edits.

\rSec1[atomicc.modcomp]{Compilation}

The AtomicC compiler generates a separate Verilog module definition
for each source AtomicC module definition.
This verilog source defines the state elements
used in the design as well as their connections (netlist).

Modules independently compiled.  Combined with "linking", which validates schedule using header files.

Physical partitioning is used to separate design into separately synthesized pieces, connected using
"long distance" signalling.  Parallel synthesis; bitstreams combined.

AtomicC execution consists of 3 phases:
\begin{itemize}
\item static elaboration: netlist generation, 
\item netlist compilation or implementation
\item and runtime.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist must only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.modfuture]{Future work}

Need to describe multi-cycle rules and pipelining.

Need to have a way to support sequencing of operations

Need to have a way to support model checking (say 'module B is a behavioral description of module A')
Show example with diff eqn solver from Sharp thesis.

C block semantics do not correctly process the 2 statements: a = b; b = a;.
(binding of read values should occur at beginning of block, so that it is clear the
2nd assign refers to the 'previous' value).
Thinking again: if we retain C semantics, we have: temp = a; a = b; b = temp;, which
gives the correct value mapping.

Multiple clock domains
