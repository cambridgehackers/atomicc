%!TEX root = std.tex
\rSec0[atomicc.basic]{Basic}

\rSec1[atomicc.intro]{Introduction}

AtomicC is a timed, structural hardware description language for
the high level specification of algorithms to be instantiated
directly in hardware.
AtomicC extends C++
with support for Guarded Atomic Actions
\cite{Hoe:Thesis,HoeArvind:TRS_Synthesis2,Dave2007}:
Bluespec-style\cite{Bluespec:www}
modules, rules, interfaces, and methods.
AtomicC does not attempt to emulate the behavior of all C++ constructs in hardware,
instead using a subset of the C++ language to specify behavioral
assignments to state elements.

The language is designed for
the construction of \textbf{modules} that are correct-by-construction \textit{composable}:
validated smaller modules can be aggregated to form
a larger validated module with
no loss of correctness of the component modules:
\begin{itemize}
\item Module interactions are performed with
latency insensitive\cite{Ng2010,AbbasB18}
\textbf{method} calls, allowing methods to enforce invocation pre-conditions
and transitive support for stalling.
\item Module behaviorial statements are encapsulated into transactions (\textbf{rules})
following ACID semantics
\cite{NikhilSemantics,GrayR93}:
%% harris2005composable, nurvitadhi2011automatic,fox2003algebraic
\begin{itemize}
\item \textit{Atomic}: all enabled rules in all modules execute on every clock cycle.
\item \textit{Consistent}: The compiler synthesizes control signals, allowing rules to fire
only when their referenced method invocations (\textit{implicit conditions})
are ready.
\item \textit{Isolated}: all rules executed during a given clock cycle are
\textit{sequentially consistent} (SC) \cite{Lamport:1979:MMC:1311099.1311750},
guaranteeing each rule executes
independently of any other rules executing at the same time
\cite[Sec.~7.1]{GrayR93}.
\item \textit{Durable}: all transactions read from and write to state elements in the design
\end{itemize}

\item An \textbf{interface} is a named collection of method signatures, defining
the behavior of an abstract data type(ADT) \cite{Liskov74programmingwith}.
Modules can declare
multiple \textbf{interfaces}, giving each interface an explicit name,
giving flexibility in coupling with other modules.
Interfaces can be exported (defined in the module) or imported (used in
the module, but defined externally), giving flexibility in algorithm
representation \cite[Sec.~4.1]{Dave:ROB}.
\item All state elements in the hardware
netlist are explicit in the source code of the design.
All module data is private to the module, accessable externally only by method invocation.
\end{itemize}
These features support the reliable reuse of pre-compiled, incrementally validated
libraries, improving productivity on large designs.

Like Connectal\cite{king2015software}, AtomicC designs may include both hardware and
software components, using interfaces to specify hardware/software communication
in a type safe manner. The AtomicC compiler generates the code and transactors to pass
arguments between hardware and software.

The AtomicC compiler 
generates a single Verilog module for each defined AtomicC module.
Existing Verilog modules can be called from and can call AtomicC
generated modules.
Standard Verilog backend tools are used to synthesize
the resulting ASIC or FPGA.

The basic building block of AtomicC is the module declaration, made of 3 parts:
\begin{itemize}
\item Instantiation of state elements used by the module,
\item Interface declarations for interacting with other modules,
\item Rules, which group assignment statements and method invocations into atomic transactions.
\end{itemize}

\rSec1[atomicc.interface]{Interface Methods}

There are 2 types of methods:
\begin{itemize}
\item \textbf{Value method functions} provide read-only access to module state elements.
\item \textbf{Action method procedures} perform write operations on state elements,
can take parameters and do not have return values.
A compiler generated
\textbf{valid} signal indicates that the caller wishes to perform the method invocation.
\end{itemize}

Both value and action methods use a compiler generated \textbf{ready} signal
to indicate when the callee is available and
stall scheduling of the calling transaction until
execution pre-conditions are statisfied.

AtomicC uses \textbf{valid/ready} \textit{hand-shaking signalling}
\cite{Fletcher2009, AXISpec} to invoke action methods,
giving both the invoker(master) and invokee(slave) the ability to control invocation
execution timing.
The master uses the \textbf{valid} signal
of an action method to show when parameter data is available
and the operation should be performed.
The method invocation succeeds only when
both \textbf{valid} and \textbf{ready} are HIGH in the same clock cycle.
\newline
In TRS notation\cite[p.~22]{Hoe:Thesis}:
\begin{itemize}[label= ]
\item $\pi(M_{i}) \equiv ready(M_{i})\ \wedge valid(M_{i})$.
\end{itemize}

\rSec2[atomicc.schedule]{Scheduling}

In software systems, to guarantee \textit{isolation} in the presence of
parallelism, \textit{dynamic allocation}\cite[p.~377]{GrayR93} of schedules
and locking\cite[Sec.~11.2]{OV11} are used.
In hardware design with AtomicC,
the set of state elements accessed by a transaction,
the operations on these state elements (read-only or write)
and the boolean condition when the transaction is performed
are all known at compile time.
This allows \textit{static allocation}\cite[Sec.~7.3.1]{GrayR93} of \textbf{schedules}
(sequences of transaction execution)
and compile time validation of SC.
\newline
The scheduling algorithm is:
\begin{itemize}
\item For each module, rules and methods that overlap usage of state elements
(\textit{read set} and \textit{write set}\cite[Sec.~10.1.2]{OV11} \cite{RosenkrantzSternsLewis})
are greedily gathered into \textit{schedule sets}.
Each set will be independently scheduled (since
there can be no interactions between sets).
\item A \textit{constraint graph} is a partially-ordered digraph modeling
the dependencies within a \textit{schedule set}:
\begin{itemize}
\item \textit{nodes} in a constraint graph represent atomic rule and method instances,
\item \textit{edges} represent \textbf{write-after-read (WAR)} ordering dependency
for a specific storage element\cite[Sec.~3]{Cain2003}.

In addition, each edge has a symbolic boolean \textit{edge condition} for when the
the ordering dependency exists: the boolean
condition when one rule/method actually reads a given state element
and the other actually writes it.
\end{itemize}

\item The transitive closure of these orders on the constraint graph nodes
dictate the \textbf{schedule} in which each rule must \textit{appear} to execute in
order to be considered SC
\cite[Sec.~11.1]{OV11}.
Of course, since all rules execute in a single cycle, "schedule" does not
refer to an actual time sequenced evolution of state,
but to a \textit{conceptual} "sub-cycle" ordering.

\item For each pair of nodes in the constraint digraph, we define the \textit{node condition}
between 2 nodes as the conjunction of the \textit{edge conditions} of all the edges between
them (i.e., the condition that \textit{any} of the edges causes a dependency).
For each cycle in the digraph, we define the \textit{path condition}
as the disjunction of the \textit{node conditions} for all sequential pairs of nodes
in the cycle (i.e., the condition that \textit{all} the edges, hence the cycle exists).

\item Since potential conflicts between methods (called from rules outside the module)
and module rules are quite common,
if cycle has some method $M$ \& some rule $R$, then the compiler can
rewrite the term $valid(R)$ to add a disjunction with the term $\neg valid(M)$, breaking
the cycle.

\item When the \textit{path condition} is not identically false, a total ordering of
the digraph can not be guaranteed and the \textit{schedule set} is not SC.
In this case, the compiler or linker reports an error,
requiring resolution by the user.
\end{itemize}

A simple example of a constraint graph is given in \ref{scheduleExample}, at the end of this document.

Since AtomicC performs scheduling analysis independantly for each
declared module, method invocation conflicts in rules cannot be validated.
Schedule processing for rule method calls is delayed until the "module group binding"
stage of linking, where separately compiled AtomicC output is combined and
verified
for SC scheduling.  Errors and conflicts detected at this stage must be repaired
in the module source text and recompiled before proceeding.

\rSec2[atomicc.schedprev]{Previous scheduling work}

In Rule Composition\cite{Dave2007}, scheduling
is reformulated in terms of rule composition, leading to a succinct discussion
of issues involved, including a concise description of the Esposito and
Performance Guarantees schedulers.  The resulting schedules are quite close
to the user-specified scheduling in AtomicC.
In contrast to AtomicC, the Bluespec kernel language they use
for analysis also has a sequential composition operator, creating rules
that execute for multiple clock cycles.

The Esposito Scheduler\cite{Esposito:Patent,Dave2007},
is the standard scheduler generation algorithm in the Bluespec Compiler.
It uses a heuristic designed to produce a concrete total ordering of rules.

The Performance Guarantees scheduler\cite{Rosenband:PerformanceGuarantees}
was proposed to address issues with intra-cycle data passing.

\newpage
\rSec1[atomicc.modcomp]{Compilation}

Modules independently compiled.  Combined with "linking", which validates schedule using header files.

Physical partitioning is used to separate design into separately synthesized pieces, connected using
"long distance" signalling.  Parallel synthesis; bitstreams combined.

AtomicC execution consists of 4 phases:
\begin{itemize}
\item \textit{compilation}: static elaboration followed by Verilog netlist generation, 
\item \textit{linking}: binding of multiple modules and verification of inter-module schedule conflicts,
\item \textit{netlist synthesis},
\item \textit{hardware execution}.
\end{itemize}

During netlist
generation, modules are instantiated by executing their
constructors. During this phase, any C++ constructs may be used, but
the resulting netlist must only contain synthesizeable components.

During netlist compilation, the netlist is analyzed and translated to
an intermediate representation and then to Verilog for simulation or
synthesis. Alternate translations are possible: to native code via
LLVM, to System C, to Gallina for formal verification with the Coq
Proof Assistant, etc.

\rSec1[atomicc.modfuture]{Future work}

Need to describe multi-cycle rules and pipelining.

Need to have a way to support sequencing of operations

Need to have a way to support model checking (say 'module B is a behavioral description of module A')
Show example with diff eqn solver from Sharp thesis.

C block semantics do not correctly process the 2 statements: a = b; b = a;.
(binding of read values should occur at beginning of block, so that it is clear the
2nd assign refers to the 'previous' value).
Thinking again: if we retain C semantics, we have: temp = a; a = b; b = temp;, which
gives the correct value mapping.

Multiple clock domains
