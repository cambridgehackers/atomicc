%!TEX root = std.tex
\rSec0[expr]{Expressions}

\gramSec[gram.expr]{Expressions}


\rSec1[expr.pre]{Preamble}

\pnum
\begin{note}
\ref{expr} defines the syntax, order of evaluation, and meaning
of expressions.\footnote{The precedence of operators is not directly specified, but it can be
derived from the syntax.}
An expression is a sequence of operators and operands that specifies a
computation. An expression can result in a value and can cause side
effects.
\end{note}

\pnum
\begin{note}
Operators can be overloaded, that is, given meaning when applied to
expressions of class type\iref{class} or enumeration
type\iref{dcl.enum}. Uses of overloaded operators are transformed into
function calls as described in~\ref{over.oper}. Overloaded operators
obey the rules for syntax and evaluation order specified in \ref{expr.compound},
but the requirements of operand type and value category are replaced
by the rules for function call. Relations between operators, such as
\tcode{++a} meaning \tcode{a+=1}, are not guaranteed for overloaded
operators\iref{over.oper}.
\end{note}

\rSec2[expr.cast]{Explicit type conversion (cast notation)}%

\pnum
The result of the expression \tcode{(T)} \grammarterm{cast-expression} is
of type \tcode{T}. The result is an lvalue if \tcode{T} is an lvalue
reference type or an rvalue reference to function type and an xvalue if \tcode{T}
is an rvalue reference to object type; otherwise the result is a prvalue.
\begin{note}
If \tcode{T} is a non-class type that is cv-qualified, the
\grammarterm{cv-qualifier}{s} are discarded when determining the type of the
resulting prvalue; see \ref{expr.prop}.
\end{note}

\pnum
An explicit type conversion can be expressed using functional
notation\iref{expr.type.conv}, a type conversion operator
(\tcode{dynamic_cast}, \tcode{static_cast}, \tcode{reinterpret_cast},
\tcode{const_cast}), or the \term{cast} notation.

\begin{bnf}
\nontermdef{cast-expression}\br
    unary-expression\br
    \terminal{(} type-id \terminal{)} cast-expression
\end{bnf}

\pnum
Any type conversion not mentioned below and not explicitly defined by
the user\iref{class.conv} is ill-formed.

\pnum
The conversions performed by

\begin{itemize}
\item a \tcode{const_cast}\iref{expr.const.cast},
\item a \tcode{static_cast}\iref{expr.static.cast},
\item a \tcode{static_cast} followed by a \tcode{const_cast},
\item a \tcode{reinterpret_cast}\iref{expr.reinterpret.cast}, or
\item a \tcode{reinterpret_cast} followed by a \tcode{const_cast},
\end{itemize}

can be performed using the cast notation of explicit type conversion.
The same semantic restrictions and behaviors apply, with the exception
that in performing a \tcode{static_cast} in the following situations the
conversion is valid even if the base class is inaccessible:

\begin{itemize}
\item a pointer to an object of derived class type or an lvalue or
rvalue of derived class type may be explicitly converted to a pointer or
reference to an unambiguous base class type, respectively;

\item a pointer to member of derived class type may be explicitly
converted to a pointer to member of an unambiguous non-virtual base
class type;

\item a pointer to an object of an unambiguous non-virtual base class
type, a glvalue of an unambiguous non-virtual base class type,
or a pointer to member of an unambiguous non-virtual base class type may
be explicitly converted to a pointer, a reference, or a pointer to
member of a derived class type, respectively.
\end{itemize}


\rSec2[atomicc.bitsize]{__bitsize}
New builtin function to return size in bits of a type or variable.

\rSec2[atomicc.cast]{__bit_cast}
This can now be used to cast any datatype to/from __int(A), allowing operations to be performed on a bit level.
