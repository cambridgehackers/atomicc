%!TEX root = std.tex
\rSec0[externalmod]{External interfacing}%

\rSec1[atomicc.softif]{Exporting interfaces for use by software}

In systems that have both hardware and software components, there is a need to marshall/demarshall
parameterized method invocations across a hardware bus or network-on-chip (NOC).
AtomicC provides this with my decorating the interface declarations with the keyword "__software".

The use of the __software keyword causes the following to be performed:
\begin{itemize}
\item The generation of serialization/deserialization code for both software and hardware side modules
to allow the method invocations to be performed in each direction
\item The generation of header files allowing compilation of software modules that
interface with the hardware
\item Integration into a modified Connectal execution framework for the orchestration of requests.
\end{itemize}

\begin{example}
\begin{codeblock}
     class EchoIfc {
         __software EchoRequest      request;               // exported interface
         __software EchoIndication   *indication;           // imported interface
     };

     class Echo __implements EchoIfc {
         bool busy;
         __int(32) itemSay;
         ...
         // implementation of method request.say(). Note the guard "if (!busy)".
         void request.say(__int(32) v) if(!busy) {
             itemSay = v;
             ...
         }
         void request.saw(__int(16) a, __int(16) b) if(!busy) {
             ...
         }
     };
\end{codeblock}
\end{example}

\begin{example}
\begin{codeblock}
#include "EchoIndication.h"  // Header file generated by AtomicC
#include "EchoRequest.h"     // Header file generated by AtomicC

class EchoIndication : public EchoIndicationWrapper
{
public:
    virtual void heard(uint32_t v) {
        // user code for handling indication
    }
    EchoIndication(unsigned int id, PortalTransportFunctions *item, void *param) :
        EchoIndicationWrapper(id, item, param) {}
};

int main(int argc, const char **argv)
{
    EchoIndication echoIndication(IfcNames_EchoIndicationH2S, &transportMux, &param);
    EchoRequestProxy echoRequestProxy(IfcNames_EchoRequestS2H, &transportMux, &param);

    // user code for sending requests
    echoRequestProxy->say(42);
}
\end{codeblock}
\end{example}

\rSec1[atomicc.verilog]{Interfacing with legacy Verilog modules}

To reference a module in verilog, fields can be declared in interface items.

\begin{example}
\begin{codeblock}
     class CNCONNECTNET2 {
         __input  __int(1)         IN1;
         __input  __int(1)         IN2;
         __output __int(1)         OUT1;
         __output __int(1)         OUT2;
     };
     class CONNECTNET2 __implements CNCONNECTNET2;
\end{codeblock}
\end{example}

This will allow references/instantiation of an externally defined verilog module CONNECTNET2
that has 2 'input' ports, IN1 and IN2, as well as 2 'output' ports, OUT1 and OUT2.

\rSec2[atomicc.param]{Parameterized modules}

Verilog modules that have module instantiation parameters can also be declared/referenced.

\begin{example}
\begin{codeblock}
     class Mmcme2MMCME2_ADV {
         __parameter const char *  BANDWIDTH;
         __parameter float         CLKFBOUT_MULT_F;
         __input  __uint(1)        CLKFBIN;
         __output __uint(1)        CLKFBOUT;
         __output __uint(1)        CLKFBOUTB;
     };
     class MMCME2_ADV __implements Mmcme2MMCME2_ADV;
\end{codeblock}
\end{example}

This example can be instantiated as:

\begin{example}
\begin{codeblock}
     class TestIfc {
         void startTest(void);
     };

     class Test __implements TestIfc {
         ...
         MMCME2_ADV#(BANDWIDTH="WIDE",CLKFBOUT_MULT_F=1.0) mmcm;
         ...
         __rule initRule {
             mmcm._.CLKFBIN = mmcm._.CLKFBOUT;
         }
     }
\end{codeblock}
\end{example}

\rSec2[atomicc.refsyntax]{Reference syntax}

\begin{bnf}
\nontermdef{atomicc-method-declaration}\br
    \opt{attribute-specifier-seq} \opt{pin-type} \opt{decl-specifier-seq} \opt{member-declarator-list} \terminal{;}
\end{bnf}

\begin{bnf}
\nontermdef{pin-type} \br
    \terminal{__input} \br
    \terminal{__output} \br
    \terminal{__inout} \br
    \terminal{__parameter}
\end{bnf}

\begin{example}
\begin{codeblock}
     class <interfaceName> {
          __input __uint(1) executeMethod;
          __input __uint(16) methodArgument;
          __output __uint(1) methodReady;
     }
\end{codeblock}
\end{example}

For '__parameter' items, supported datatypes include: "const char *", "float", "int".

Factoring of interfaces into sub interfaces is also supported.

\rSec2[atomicc.clockReset]{Clock/reset ports}
Note that if interface port pins are declared in a module interface declaration, then
CLK and nRST are _not_ automatically declared/instantiated.  (Since the user needs the
flexibility to not require them when interfacing with legacy code).

Note that this also allows arbitrary signals (like the output of clock generators) to be
passed to modules as CLK/nRST signals.  (For Atomicc generated modules, please note that the
default clock/reset signals for a module will always have these names)

\rSec2[atomicc.itool]{Import tooling}

There is a tool to automate the creation of AtomicC header files from verilog source files.
\begin{example}
\begin{codeblock}
     atomiccImport -o MMCME2_ADV.h -C MMCME2_ADV -P Mmcme2 zynq.lib
     atomiccImport -o VMMCME2_ADV.h -C MMCME2_ADV -P Mmcme2 MMCME2_ADV.v
\end{codeblock}
\end{example}
